.TH "el_init" "3" "28 February 2019 (v0.5.0)" "bofc.pl"
.SH NAME
.PP
.B el_init
- initializes library and el for printing.
.SH SYNOPSIS
.PP
.B "#include <embedlog.h>"
.PP
.BI "int el_init(void)"
.br
.BI "int el_oinit(struct el *" el ")"
.br
.BI "struct el * el_new(void)"
.SH DESCRIPTION
.PP
There are two types of functions in
.BR embedlog.
Functions that use global static structure inside library, these functions don't
accept
.I el
argument with options.
.PP
Another type are functions that accept additional
.I el
argument. These functions are prefixed with
.BR el_o .
.PP
All functions (el_o or not) are "line" thread-safe (provided that
.B \-\-enable\-reentrant
is turned on).
That means library buffers whole line before it calls
.B puts
function, so lines in output will not overlap.
.PP
NOTE: this may not be entirely true for every operating system there is! Yes,
.B embedlog
will always buffer and print whole lines, but OS may, for example interrupt
.B puts
call from thread1, and call
.B puts
from thread2.
In such case output will be mangled with 2 different lines.
While this situation is very rare, it's only fair to mention it.
If in doubt, check
.B stdio
implementation in your operating system.
.PP
.BR el_init (3)
initializes static global option structure. This option structure is used by all
functions that don't accept
.I el
object parameter.
If you want to use only one instance of
.BR embedlog ,
this is the function you want to use.
.PP
.BR el_oinit (3)
initializes only
.I el
struct passed to it.
Functions that accepts
.I el
object may be used.
If you want to have multiple embedlog instances (ie. one for program logs,
and one for queries) that stores logs differently - this is the function you
want to use.
Object initialized with this function must be deinitialized with
.BR el_ocleanup (3)
function.
.PP
.BR el_new (3)
Works in the same way as
.BR el_oinit (3)
but function returns newly heap-allocated pointer to
.I el
struct.
Object created with this function must be destroyed with
.BR el_destroy (3)
function.
.SH NOTES
Keeps in mind that using
.BR el_oinit (3)
function is suscible to ABI breakage.
If stable ABI is important to you, use
.BR el_new (3)
function.
Please check
.BR el_overview (3)
for more information about this.
.SH RETURN VALUE
.PP
.BR el_init (3)
cannot fail and always returns 0.
.BR el_oinit (3)
function will return 0 upon success and -1 on errors.
.BR el_new (3)
returns valid pointer on success and
.B NULL
when error occurs.
.SH ERRORS
.PP
.BR el_oinit (3)
can return:
.TP
.B EINVAL
.I el
object is invalid (null).
.PP
.BR el_new (3)
can return:
.TP
.B ENOMEM
Not enough memory in the system to perform necessary memory allocations.
.SH EXAMPLE
.PP
Note: error handling has been ommited for clarity sake
.PP
.nf
    #include <embedlog.h>

    int main(void)
    {
        struct el  el, *elp;

        /* initialize default and two custom el objects */
        el_init();
        el_oinit(&el);
        elp = el_new();

        /* make el to print to file and stderr */
        el_ooption(&el, EL_OUT, EL_OUT_FILE | EL_OUT_STDERR);
        el_ooption(&el, EL_FPATH, "/tmp/test.log");

        /* print messages */
        el_print(ELI, "will print to stderr");
        el_oprint(ELI, &el, "will print to file /tmp/test.log and stderr");
        el_oprint(ELN, elp, "print to stderr");

        /* cleanup after any initialization code (like fopen) */
        el_destroy(elp);
        el_ocleanup(&el);
        el_cleanup();

        return 0;
    }
.fi
.SH SEE ALSO
.PP
.BR el_overview (7),
.BR el_cleanup (3),
.BR el_destroy (3),
.BR el_flush (3),
.BR el_ocleanup (3),
.BR el_oflush (3),
.BR el_ooption (3),
.BR el_operror (3),
.BR el_opmemory (3),
.BR el_opmemory_table (3),
.BR el_oprint (3),
.BR el_option (3),
.BR el_oputs (3),
.BR el_ovprint (3),
.BR el_perror (3),
.BR el_pmemory (3),
.BR el_pmemory_table (3),
.BR el_print (3),
.BR el_puts (3),
.BR el_vprint (3).
